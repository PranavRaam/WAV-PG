import React, { useState, useEffect, useMemo } from 'react';
import { FiPhone, FiMail, FiLinkedin, FiMoreHorizontal, FiFilter, FiChevronDown, FiX, FiRefreshCw, FiPieChart, FiBarChart2 } from 'react-icons/fi';
import { mockResponseData, mockTrendData, getDateRange, isDateInRange } from './ResponseData';
import { PieChart, Pie, Cell, Legend, Tooltip, ResponsiveContainer, ScatterChart, Scatter, XAxis, YAxis, CartesianGrid, ZAxis, ReferenceLine } from 'recharts';
import './ResponseChart.css';

// Options for filters
const timeRangeOptions = [
  { label: 'Last 7 Days', value: '7d' },
  { label: 'Last 30 Days', value: '30d' },
  { label: 'Last Quarter', value: 'quarter' },
  { label: 'Year to Date', value: 'ytd' },
  { label: 'Custom Range', value: 'custom' }
];

const outcomeOptions = [
  { label: 'All Outcomes', value: 'all' },
  { label: 'Interested', value: 'Interested' },
  { label: 'Replied', value: 'Replied' },
  { label: 'No Reply', value: 'No Reply' }
];

const regionOptions = [
  { label: 'All Regions', value: 'all' },
  { label: 'Northeast', value: 'NE' },
  { label: 'Southeast', value: 'SE' },
  { label: 'Midwest', value: 'MW' },
  { label: 'Southwest', value: 'SW' },
  { label: 'West', value: 'W' }
];

// Define different target response times for each channel (in minutes)
const targetResponseTimes = {
  phone: 10,    // 10 minutes for phone calls
  email: 30,    // 30 minutes for emails
  linkedin: 60, // 60 minutes for LinkedIn messages
  other: 120    // 120 minutes for other channels
};

const channelIcons = {
  phone: <FiPhone className="channel-icon" />,
  email: <FiMail className="channel-icon" />,
  linkedin: <FiLinkedin className="channel-icon" />,
  other: <FiMoreHorizontal className="channel-icon" />
};

const channelLabels = {
  phone: 'Phone',
  email: 'Email',
  linkedin: 'LinkedIn',
  other: 'Others'
};

// Channel x-axis positions for scatter plot
const channelPositions = {
  phone: 1,
  email: 2,
  linkedin: 3,
  other: 4
};

// Colors for the pie charts
const COLORS = {
  good: 'var(--color-success)',
  average: 'var(--color-warning)',
  poor: 'var(--color-danger)'
};

const ResponseChart = ({ searchQuery = '' }) => {
  const [selectedChannel, setSelectedChannel] = useState(null);
  const [showFilters, setShowFilters] = useState(false);
  const [timeRange, setTimeRange] = useState('7d');
  const [selectedOutcome, setSelectedOutcome] = useState('all');
  const [selectedRegion, setSelectedRegion] = useState('all');
  const [originalData] = useState(mockResponseData); // Keep original data for filtering
  const [filteredData, setFilteredData] = useState(mockResponseData);
  const [dateRange, setDateRange] = useState(getDateRange('7d'));
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [customStartDate, setCustomStartDate] = useState('2025-05-01');
  const [customEndDate, setCustomEndDate] = useState('2025-05-03');
  const [isLoading, setIsLoading] = useState(false);
  const [activeFilters, setActiveFilters] = useState(0);
  const [viewMode, setViewMode] = useState('pie'); // 'pie' or 'scatter'

  // Apply filters to data
  useEffect(() => {
    // Show loading state briefly to provide visual feedback
    setIsLoading(true);
    
    // Get date range based on selected time range
    let range = timeRange === 'custom' 
      ? { start: new Date(customStartDate), end: new Date(customEndDate) }
      : getDateRange(timeRange);
    
    setDateRange(range);
    
    // Calculate number of active filters for visual feedback
    let count = 0;
    if (timeRange !== '7d') count++;
    if (selectedOutcome !== 'all') count++;
    if (selectedRegion !== 'all') count++;
    if (searchQuery.trim() !== '') count++;
    setActiveFilters(count);

    // Small delay to show loading state (provides better UX feedback that filters are applied)
    const timerId = setTimeout(() => {
    // Filter data based on all criteria
    const filteredResults = {
      phone: filterChannelData(originalData.phone),
      email: filterChannelData(originalData.email),
      linkedin: filterChannelData(originalData.linkedin),
      other: filterChannelData(originalData.other)
    };
    
    setFilteredData(filteredResults);
      setIsLoading(false);
    }, 300);
    
    return () => clearTimeout(timerId);
    
  }, [timeRange, selectedOutcome, selectedRegion, customStartDate, customEndDate, originalData, searchQuery]);

  // Helper function to filter data for a specific channel
  const filterChannelData = (channelData) => {
    return channelData.filter(item => {
      // Filter by date range
      const isInTimeRange = isDateInRange(item.date, dateRange);
      
      // Filter by outcome
      const matchesOutcome = selectedOutcome === 'all' || item.outcome === selectedOutcome;
      
      // Filter by region
      const matchesRegion = selectedRegion === 'all' || item.region === selectedRegion;
      
      // Filter by search query (division, statistical area, region, or PG name)
      const matchesSearch = !searchQuery.trim() || 
        (item.division && item.division.toLowerCase().includes(searchQuery.toLowerCase())) ||
        (item.statisticalArea && item.statisticalArea.toLowerCase().includes(searchQuery.toLowerCase())) ||
        (item.region && item.region.toLowerCase().includes(searchQuery.toLowerCase())) ||
        (item.pgName && item.pgName.toLowerCase().includes(searchQuery.toLowerCase()));
      
      return isInTimeRange && matchesOutcome && matchesRegion && matchesSearch;
    });
  };

  // Helper function to format response time in minutes
  const formatResponseTimeMinutes = (minutes) => {
    if (minutes < 60) {
      return `${Math.round(minutes)} min`;
    }
    const hours = Math.floor(minutes / 60);
    const remainingMinutes = Math.round(minutes % 60);
    return remainingMinutes > 0 ? `${hours}h ${remainingMinutes}m` : `${hours}h`;
  };

  // Calculate response time categories for pie charts
  const pieChartData = useMemo(() => {
    const calculateCategoryData = (channelData, targetTime) => {
      if (!channelData.length) return [
        { name: 'Good', value: 0, color: COLORS.good },
        { name: 'Average', value: 0, color: COLORS.average },
        { name: 'Poor', value: 0, color: COLORS.poor }
      ];
      
      let good = 0;
      let average = 0;
      let poor = 0;
      
      channelData.forEach(item => {
        // Convert hours to minutes for consistent comparison with targetTime (which is in minutes)
        const responseTimeMinutes = item.responseTime * 60;
        
        if (responseTimeMinutes <= targetTime) {
          good++;
        } else if (responseTimeMinutes <= targetTime * 1.5) {
          average++;
        } else {
          poor++;
        }
      });
      
      return [
        { name: 'Good', value: good, color: COLORS.good },
        { name: 'Average', value: average, color: COLORS.average },
        { name: 'Poor', value: poor, color: COLORS.poor }
      ];
    };
    
    return {
      phone: calculateCategoryData(filteredData.phone, targetResponseTimes.phone),
      email: calculateCategoryData(filteredData.email, targetResponseTimes.email),
      linkedin: calculateCategoryData(filteredData.linkedin, targetResponseTimes.linkedin),
      other: calculateCategoryData(filteredData.other, targetResponseTimes.other)
    };
  }, [filteredData]);

  // Prepare data for scatter plot with minutes instead of hours
  const scatterData = useMemo(() => {
    // Group all data in a single array but with proper formatting for timeline view
    const allData = [];
    
    // Add phone data points
    filteredData.phone.forEach((item) => {
      // Convert response time from hours to minutes
      const responseTimeMinutes = item.responseTime * 60;
      allData.push({
        x: new Date(item.date).getTime(), // Use actual date for x-axis
        y: responseTimeMinutes,
        z: 100, // Size value for the point
        name: 'Phone',
        pgName: item.pgName || 'Unknown PG',
        persona: item.persona || 'Unknown',
        outcome: item.outcome || 'Unknown',
        region: item.region || 'Unknown',
        date: item.date,
        responseTime: responseTimeMinutes,
        responseTimeFormatted: formatResponseTimeMinutes(responseTimeMinutes),
        target: targetResponseTimes.phone,
        channel: 'phone'
      });
    });
    
    // Add email data points
    filteredData.email.forEach((item) => {
      const responseTimeMinutes = item.responseTime * 60;
      allData.push({
        x: new Date(item.date).getTime(),
        y: responseTimeMinutes,
        z: 100,
        name: 'Email',
        pgName: item.pgName || 'Unknown PG',
        persona: item.persona || 'Unknown',
        outcome: item.outcome || 'Unknown',
        region: item.region || 'Unknown',
        date: item.date,
        responseTime: responseTimeMinutes,
        responseTimeFormatted: formatResponseTimeMinutes(responseTimeMinutes),
        target: targetResponseTimes.email,
        channel: 'email'
      });
    });
    
    // Add linkedin data points
    filteredData.linkedin.forEach((item) => {
      const responseTimeMinutes = item.responseTime * 60;
      allData.push({
        x: new Date(item.date).getTime(),
        y: responseTimeMinutes,
        z: 100,
        name: 'LinkedIn',
        pgName: item.pgName || 'Unknown PG',
        persona: item.persona || 'Unknown',
        outcome: item.outcome || 'Unknown',
        region: item.region || 'Unknown',
        date: item.date,
        responseTime: responseTimeMinutes,
        responseTimeFormatted: formatResponseTimeMinutes(responseTimeMinutes),
        target: targetResponseTimes.linkedin,
        channel: 'linkedin'
      });
    });
    
    // Add other data points
    filteredData.other.forEach((item) => {
      const responseTimeMinutes = item.responseTime * 60;
      allData.push({
        x: new Date(item.date).getTime(),
        y: responseTimeMinutes,
        z: 100,
        name: 'Others',
        pgName: item.pgName || 'Unknown PG',
        persona: item.persona || 'Unknown',
        outcome: item.outcome || 'Unknown',
        region: item.region || 'Unknown',
        date: item.date,
        responseTime: responseTimeMinutes,
        responseTimeFormatted: formatResponseTimeMinutes(responseTimeMinutes),
        target: targetResponseTimes.other,
        channel: 'other'
      });
    });
    
    return allData;
  }, [filteredData]);

  // Group scatter data by channel for separate series display
  const groupedScatterData = useMemo(() => {
    return {
      phone: scatterData.filter(item => item.channel === 'phone'),
      email: scatterData.filter(item => item.channel === 'email'),
      linkedin: scatterData.filter(item => item.channel === 'linkedin'),
      other: scatterData.filter(item => item.channel === 'other')
    };
  }, [scatterData]);

  // Calculate date range for x-axis domain and group into weeks
  const xAxisDomain = useMemo(() => {
    if (!scatterData.length) {
      // Default range if no data
      const now = new Date();
      const sevenDaysAgo = new Date();
      sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
      return [sevenDaysAgo.getTime(), now.getTime()];
    }
    
    const dates = scatterData.map(item => item.x);
    let minDate = Math.min(...dates);
    let maxDate = Math.max(...dates);
    
    // Add padding to the range
    const padding = 24 * 60 * 60 * 1000; // 1 day padding
    minDate -= padding;
    maxDate += padding;
    
    return [minDate, maxDate];
  }, [scatterData]);
  
  // Format day of week and date
  const formatDayOfWeek = (timestamp) => {
    const date = new Date(timestamp);
    const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    const dayName = days[date.getDay()];
    // Format: "Day, MM/DD"
    return `${dayName}, ${(date.getMonth() + 1)}/${date.getDate()}`;
  };
  
  // Generate custom ticks for days
  const getDailyTicks = useMemo(() => {
    if (!scatterData.length) return [];
    
    const startDate = new Date(xAxisDomain[0]);
    const endDate = new Date(xAxisDomain[1]);
    
    const ticks = [];
    let currentDate = new Date(startDate);
    
    // Generate a tick for each day
    while (currentDate <= endDate) {
      ticks.push(currentDate.getTime());
      // Move to next day
      currentDate.setDate(currentDate.getDate() + 1);
    }
    
    return ticks;
  }, [scatterData, xAxisDomain]);
  
  // Calculate summary statistics
  const channelStats = useMemo(() => {
    const calcStats = (data, targetTime) => {
      if (!data.length) return { avg: 0, median: 0, count: 0, performance: 'no-data' };
      
      // Sort the response times
      const sortedTimes = [...data].sort((a, b) => a.responseTime - b.responseTime);
      const count = sortedTimes.length;
      
      // Extract just the response times
      const times = sortedTimes.map(item => item.responseTime);
      
      // Calculate average and median
      const avg = times.reduce((sum, val) => sum + val, 0) / count;
      const median = times[Math.floor(count * 0.5)];
      
      // Determine performance category
      let performance = 'poor';
      if (median <= targetTime) {
        performance = 'good';
      } else if (median <= targetTime * 1.5) {
        performance = 'average';
      }
      
      return {
        avg: parseFloat(avg.toFixed(1)),
        median: parseFloat(median.toFixed(1)),
        count,
        performance
      };
    };
    
    return [
      {
        name: 'Phone',
        ...calcStats(filteredData.phone, targetResponseTimes.phone),
        target: targetResponseTimes.phone,
        channel: 'phone'
      },
      {
        name: 'Email',
        ...calcStats(filteredData.email, targetResponseTimes.email),
        target: targetResponseTimes.email,
        channel: 'email'
      },
      {
        name: 'LinkedIn',
        ...calcStats(filteredData.linkedin, targetResponseTimes.linkedin),
        target: targetResponseTimes.linkedin,
        channel: 'linkedin'
      },
      {
        name: 'Others',
        ...calcStats(filteredData.other, targetResponseTimes.other),
        target: targetResponseTimes.other,
        channel: 'other'
      }
    ];
  }, [filteredData]);

  // Original helper function for hours (used for pie chart statistics)
  const formatResponseTime = (hours) => {
    if (hours < 1) {
      return `${Math.round(hours * 60)}m`;
    }
    const wholeHours = Math.floor(hours);
    const minutes = Math.round((hours - wholeHours) * 60);
    return minutes > 0 ? `${wholeHours}h ${minutes}m` : `${wholeHours}h`;
  };

  // Custom tooltip for pie charts
  const PieTooltip = ({ active, payload }) => {
    if (active && payload && payload.length) {
      const data = payload[0].payload;
      const total = payload.reduce((sum, entry) => sum + entry.value, 0);
      return (
        <div className="custom-tooltip">
          <p className="tooltip-label">{data.name} Response Times</p>
          <p className="tooltip-metric">
            <span>Count: </span>
            <span className="tooltip-value">{data.value}</span>
          </p>
          <p className="tooltip-metric">
            <span>Percentage: </span>
            <span className="tooltip-value">
              {data.value > 0 && total > 0
                ? `${Math.round((data.value / total) * 100)}%` 
                : '0%'}
            </span>
          </p>
        </div>
      );
    }
    return null;
  };

  // Custom tooltip for scatter plot
  const ScatterTooltip = ({ active, payload }) => {
    if (active && payload && payload.length) {
      const data = payload[0].payload;
      // Format date for display
      const date = new Date(data.date);
      const formattedDate = `${date.getMonth() + 1}/${date.getDate()}`;
      const formattedTime = date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
      
      return (
        <div className="custom-tooltip">
          <p className="tooltip-header">{formattedDate}</p>
          <p className="tooltip-metric">
            <span>Channel: </span>
            <span className="tooltip-value">{data.name}</span>
          </p>
          <p className="tooltip-metric">
            <span>Response Time: </span>
            <span className="tooltip-value">{data.responseTimeFormatted}</span>
          </p>
          <p className="tooltip-metric">
            <span>Target Time: </span>
            <span className="tooltip-value">{formatResponseTimeMinutes(data.target)}</span>
          </p>
          <p className="tooltip-metric">
            <span>PG: </span>
            <span className="tooltip-value">{data.pgName}</span>
          </p>
          <p className="tooltip-metric">
            <span>Persona: </span>
            <span className="tooltip-value">{data.persona}</span>
          </p>
          <p className="tooltip-metric">
            <span>Performance: </span>
            <span className={`tooltip-value ${data.responseTime <= data.target ? 'good' : (data.responseTime <= data.target * 1.5 ? 'average' : 'poor')}`}>
              {data.responseTime <= data.target ? 'Good' : (data.responseTime <= data.target * 1.5 ? 'Average' : 'Poor')}
            </span>
          </p>
        </div>
      );
    }
    return null;
  };
  
  // Function to reset all filters
  const resetFilters = () => {
    setIsLoading(true);
    setTimeRange('7d');
    setSelectedOutcome('all');
    setSelectedRegion('all');
    setCustomStartDate('2025-05-01');
    setCustomEndDate('2025-05-03');
    
    // Small delay to show loading state
    setTimeout(() => setIsLoading(false), 300);
  };

  // Handle custom date range
  const handleCustomDateChange = () => {
    if (new Date(customStartDate) <= new Date(customEndDate)) {
      setTimeRange('custom');
      setShowDatePicker(false);
    }
  };

  // Custom label formatter for the pie chart
  const renderCustomizedLabel = ({ cx, cy, midAngle, innerRadius, outerRadius, percent, index, name, value }) => {
    if (value === 0) return null;
    
    const RADIAN = Math.PI / 180;
    const radius = outerRadius * 0.8;
    const x = cx + radius * Math.cos(-midAngle * RADIAN);
    const y = cy + radius * Math.sin(-midAngle * RADIAN);
    
    return (
      <text 
        x={x} 
        y={y} 
        fill="#333" 
        textAnchor={x > cx ? 'start' : 'end'} 
        dominantBaseline="central"
        fontSize={12}
      >
        {`${name}: ${value} (${(percent * 100).toFixed(0)}%)`}
      </text>
    );
  };
  
  // Helper to check if chart has no data
  const hasNoData = (data) => {
    return data.every(item => item.value === 0);
  };

  // Calculate point color based on performance vs target (minutes)
  const getPointColor = (entry) => {
    if (entry.channel === 'phone') {
      return entry.responseTime <= targetResponseTimes.phone 
        ? 'var(--color-success)' 
        : entry.responseTime <= targetResponseTimes.phone * 1.5 
          ? 'var(--color-warning)' 
          : 'var(--color-danger)';
    } else if (entry.channel === 'email') {
      return entry.responseTime <= targetResponseTimes.email 
        ? 'var(--color-success)' 
        : entry.responseTime <= targetResponseTimes.email * 1.5 
          ? 'var(--color-warning)' 
          : 'var(--color-danger)';
    } else if (entry.channel === 'linkedin') {
      return entry.responseTime <= targetResponseTimes.linkedin 
        ? 'var(--color-success)' 
        : entry.responseTime <= targetResponseTimes.linkedin * 1.5 
          ? 'var(--color-warning)' 
          : 'var(--color-danger)';
    } else {
      return entry.responseTime <= targetResponseTimes.other 
        ? 'var(--color-success)' 
        : entry.responseTime <= targetResponseTimes.other * 1.5 
          ? 'var(--color-warning)' 
          : 'var(--color-danger)';
    }
  };

  // Toggle between visualization modes
  const toggleViewMode = () => {
    setViewMode(viewMode === 'pie' ? 'scatter' : 'pie');
  };

  // Define Y-axis ticks for minutes
  const getResponseTimeMinuteTicks = () => {
    return [0, 30, 60, 120, 180, 240];
  };

  return (
    <div className="response-chart-container">
      <div className="chart-header">
        <div className="header-left">
          <h3>Response Performance by Channel</h3>
          {activeFilters > 0 && (
            <div className="active-filters-badge">
              {activeFilters} {activeFilters === 1 ? 'filter' : 'filters'} active
            </div>
          )}
        </div>
        <div className="chart-actions">
          <button 
            className="view-toggle-button" 
            onClick={toggleViewMode}
            title={viewMode === 'pie' ? 'Switch to Scatter Plot' : 'Switch to Pie Charts'}
          >
            {viewMode === 'pie' ? <FiBarChart2 /> : <FiPieChart />}
            {viewMode === 'pie' ? ' Show Plot View' : ' Show Pie View'}
          </button>
          <button 
            className={`filter-button ${showFilters ? 'active' : ''}`} 
            onClick={() => setShowFilters(!showFilters)}
          >
            <FiFilter /> Filters {activeFilters > 0 && <span className="filter-count">{activeFilters}</span>}
          </button>
        </div>
      </div>
      
      {showFilters && (
        <div className="filter-panel">
          <div className="filter-groups">
            <div className="filter-group">
              <label>Time Range</label>
              <div className="filter-dropdown">
                <button 
                  className="dropdown-trigger"
                  onClick={() => setShowDatePicker(!showDatePicker)}
                >
                  {timeRangeOptions.find(o => o.value === timeRange)?.label || 'Select Range'}
                  <FiChevronDown />
                </button>
                {!showDatePicker ? (
                  <div className="dropdown-menu">
                    {timeRangeOptions.map(option => (
                      <div 
                        key={option.value} 
                        className={`dropdown-item ${timeRange === option.value ? 'selected' : ''}`}
                        onClick={() => {
                          setTimeRange(option.value);
                          if (option.value === 'custom') {
                            setShowDatePicker(true);
                          }
                        }}
                      >
                        {option.label}
                      </div>
                    ))}
                  </div>
                ) : (
                  <div className="date-picker">
                    <div className="date-inputs">
                      <div className="date-input-group">
                        <label>Start Date</label>
                      <input 
                        type="date" 
                        value={customStartDate}
                        max={customEndDate}
                          onChange={(e) => setCustomStartDate(e.target.value)}
                      />
                    </div>
                      <div className="date-input-group">
                        <label>End Date</label>
                      <input 
                        type="date" 
                        value={customEndDate}
                        min={customStartDate}
                          onChange={(e) => setCustomEndDate(e.target.value)}
                      />
                    </div>
                    </div>
                    <div className="date-actions">
                      <button onClick={handleCustomDateChange}>Apply</button>
                      <button onClick={() => setShowDatePicker(false)}>Cancel</button>
                  </div>
                </div>
              )}
            </div>
            
            <div className="filter-group">
              <label>Outcome</label>
              <div className="filter-dropdown">
                <button className="dropdown-trigger">
                  {outcomeOptions.find(o => o.value === selectedOutcome)?.label || 'Select Outcome'}
                  <FiChevronDown />
                </button>
                <div className="dropdown-menu">
                {outcomeOptions.map(option => (
                    <div 
                      key={option.value} 
                      className={`dropdown-item ${selectedOutcome === option.value ? 'selected' : ''}`}
                      onClick={() => setSelectedOutcome(option.value)}
                    >
                      {option.label}
                    </div>
                  ))}
                </div>
              </div>
            </div>
            
            <div className="filter-group">
              <label>Region</label>
              <div className="filter-dropdown">
                <button className="dropdown-trigger">
                  {regionOptions.find(o => o.value === selectedRegion)?.label || 'Select Region'}
                  <FiChevronDown />
                </button>
                <div className="dropdown-menu">
                {regionOptions.map(option => (
                    <div 
                      key={option.value} 
                      className={`dropdown-item ${selectedRegion === option.value ? 'selected' : ''}`}
                      onClick={() => setSelectedRegion(option.value)}
                    >
                      {option.label}
                    </div>
                  ))}
                </div>
              </div>
            </div>
          </div>
          
          <div className="filter-footer">
            <div className="filter-summary">
              {(timeRange !== '7d' || selectedOutcome !== 'all' || selectedRegion !== 'all') && (
                <div className="active-filters">
                  <span>Active Filters:</span>
                  {timeRange !== '7d' && (
                    <span className="filter-tag">
                      {timeRangeOptions.find(o => o.value === timeRange)?.label}
                      <FiX onClick={() => setTimeRange('7d')} />
                    </span>
                  )}
                  {selectedOutcome !== 'all' && (
                    <span className="filter-tag">
                      {selectedOutcome}
                      <FiX onClick={() => setSelectedOutcome('all')} />
                    </span>
                  )}
                  {selectedRegion !== 'all' && (
                    <span className="filter-tag">
                      {regionOptions.find(o => o.value === selectedRegion)?.label}
                      <FiX onClick={() => setSelectedRegion('all')} />
                    </span>
                  )}
                  {searchQuery.trim() !== '' && (
                    <span className="filter-tag">
                      Search: "{searchQuery}"
                    </span>
                  )}
                </div>
              )}
            </div>
            <button className="reset-button" onClick={resetFilters}>Reset Filters</button>
          </div>
        </div>
      )}
      
      <div className="chart-legend">
        <div className="legend-item">
          <div className="legend-box good"></div>
          <span>Good Response Time (Below Target)</span>
        </div>
        <div className="legend-item">
          <div className="legend-box average"></div>
          <span>Average Response Time (Up to 50% Above Target)</span>
          </div>
        <div className="legend-item">
          <div className="legend-box poor"></div>
          <span>Poor Response Time (More than 50% Above Target)</span>
        </div>
        {viewMode === 'scatter' && (
          <div className="legend-item">
            <div className="legend-line target"></div>
            <span>Target Response Time</span>
            </div>
        )}
                </div>
                
      {isLoading ? (
        <div className="loading-overlay">
          <FiRefreshCw className="loading-icon" />
          <div>Updating charts...</div>
                </div>
      ) : viewMode === 'pie' ? (
        // Pie Chart View
        <div className="pie-charts-grid">
          {/* Phone Chart */}
          <div className="pie-chart-container">
            <div className="pie-chart-header">
              <div className="channel-icon-wrapper">
                {channelIcons.phone}
                </div>
              <h4>Phone</h4>
              <div className="target-time">Target: {formatResponseTime(targetResponseTimes.phone)}</div>
              <div className="data-count">{filteredData.phone.length} data points</div>
              </div>
            <div className="pie-chart">
              <ResponsiveContainer width="100%" height={200}>
                {hasNoData(pieChartData.phone) ? (
                  <div className="no-data-message">No data available</div>
                ) : (
                  <PieChart>
                    <Pie
                      data={pieChartData.phone}
                      cx="50%"
                      cy="50%"
                      labelLine={false}
                      label={renderCustomizedLabel}
                      outerRadius={80}
                      fill="#8884d8"
                      dataKey="value"
                    >
                      {pieChartData.phone.map((entry, index) => (
                        <Cell key={`cell-${index}`} fill={entry.color} />
                      ))}
                    </Pie>
                    <Tooltip content={<PieTooltip />} />
                  </PieChart>
                )}
              </ResponsiveContainer>
                </div>
                </div>
                
          {/* Email Chart */}
          <div className="pie-chart-container">
            <div className="pie-chart-header">
              <div className="channel-icon-wrapper">
                {channelIcons.email}
                </div>
              <h4>Email</h4>
              <div className="target-time">Target: {formatResponseTime(targetResponseTimes.email)}</div>
              <div className="data-count">{filteredData.email.length} data points</div>
              </div>
            <div className="pie-chart">
              <ResponsiveContainer width="100%" height={200}>
                {hasNoData(pieChartData.email) ? (
                  <div className="no-data-message">No data available</div>
                ) : (
                  <PieChart>
                    <Pie
                      data={pieChartData.email}
                      cx="50%"
                      cy="50%"
                      labelLine={false}
                      label={renderCustomizedLabel}
                      outerRadius={80}
                      fill="#8884d8"
                      dataKey="value"
                    >
                      {pieChartData.email.map((entry, index) => (
                        <Cell key={`cell-${index}`} fill={entry.color} />
                      ))}
                    </Pie>
                    <Tooltip content={<PieTooltip />} />
                  </PieChart>
                )}
              </ResponsiveContainer>
                </div>
                </div>
                
          {/* LinkedIn Chart */}
          <div className="pie-chart-container">
            <div className="pie-chart-header">
              <div className="channel-icon-wrapper">
                {channelIcons.linkedin}
                </div>
              <h4>LinkedIn</h4>
              <div className="target-time">Target: {formatResponseTime(targetResponseTimes.linkedin)}</div>
              <div className="data-count">{filteredData.linkedin.length} data points</div>
              </div>
            <div className="pie-chart">
              <ResponsiveContainer width="100%" height={200}>
                {hasNoData(pieChartData.linkedin) ? (
                  <div className="no-data-message">No data available</div>
                ) : (
                  <PieChart>
                    <Pie
                      data={pieChartData.linkedin}
                      cx="50%"
                      cy="50%"
                      labelLine={false}
                      label={renderCustomizedLabel}
                      outerRadius={80}
                      fill="#8884d8"
                      dataKey="value"
                    >
                      {pieChartData.linkedin.map((entry, index) => (
                        <Cell key={`cell-${index}`} fill={entry.color} />
                      ))}
                    </Pie>
                    <Tooltip content={<PieTooltip />} />
                  </PieChart>
                )}
              </ResponsiveContainer>
                </div>
                </div>
                
          {/* Others Chart */}
          <div className="pie-chart-container">
            <div className="pie-chart-header">
              <div className="channel-icon-wrapper">
                {channelIcons.other}
                </div>
              <h4>Others</h4>
              <div className="target-time">Target: {formatResponseTime(targetResponseTimes.other)}</div>
              <div className="data-count">{filteredData.other.length} data points</div>
              </div>
            <div className="pie-chart">
              <ResponsiveContainer width="100%" height={200}>
                {hasNoData(pieChartData.other) ? (
                  <div className="no-data-message">No data available</div>
                ) : (
                  <PieChart>
                    <Pie
                      data={pieChartData.other}
                      cx="50%"
                      cy="50%"
                      labelLine={false}
                      label={renderCustomizedLabel}
                      outerRadius={80}
                      fill="#8884d8"
                      dataKey="value"
                    >
                      {pieChartData.other.map((entry, index) => (
                        <Cell key={`cell-${index}`} fill={entry.color} />
                      ))}
                    </Pie>
                    <Tooltip content={<PieTooltip />} />
                  </PieChart>
                )}
              </ResponsiveContainer>
        </div>
          </div>
        </div>
      ) : (
        // Scatter Plot View
        <div className="scatter-plot-container">
          <div className="channel-headers">
            <div className="channel-header">
              <div className="channel-icon-wrapper">
                {channelIcons.phone}
      </div>
              <div className="channel-label">Phone</div>
              <div className="channel-count">{filteredData.phone.length}</div>
              </div>
            <div className="channel-header">
              <div className="channel-icon-wrapper">
                {channelIcons.email}
            </div>
              <div className="channel-label">Email</div>
              <div className="channel-count">{filteredData.email.length}</div>
              </div>
            <div className="channel-header">
              <div className="channel-icon-wrapper">
                {channelIcons.linkedin}
            </div>
              <div className="channel-label">LinkedIn</div>
              <div className="channel-count">{filteredData.linkedin.length}</div>
              </div>
            <div className="channel-header">
              <div className="channel-icon-wrapper">
                {channelIcons.other}
            </div>
              <div className="channel-label">Others</div>
              <div className="channel-count">{filteredData.other.length}</div>
              </div>
            </div>
          <ResponsiveContainer width="100%" height={450}>
            <ScatterChart
              margin={{ top: 20, right: 20, bottom: 30, left: 20 }}
            >
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis 
                type="number" 
                dataKey="x" 
                name="Date" 
                domain={xAxisDomain}
                scale="time"
                ticks={getDailyTicks}
                tickFormatter={formatDayOfWeek}
                tick={{ fontSize: 12, textAnchor: 'end', angle: -30 }}
                height={50}
                tickMargin={15}
                interval={0}
              />
              <YAxis 
                type="number" 
                dataKey="y" 
                name="Response Time" 
                label={{ value: 'Response Time (minutes)', angle: -90, position: 'insideLeft' }}
                domain={[0, 240]}
                ticks={getResponseTimeMinuteTicks()}
                tick={{ fontSize: 12 }}
                tickFormatter={(value) => value === 0 ? '0' : `${value}m`}
              />
              <ZAxis type="number" dataKey="z" range={[60, 60]} />
              <Tooltip content={<ScatterTooltip />} />
              
              {/* Target lines for each channel across the chart */}
              <ReferenceLine 
                y={targetResponseTimes.phone} 
                stroke="red" 
                strokeWidth={2}
                isFront={false}
                ifOverflow="extendDomain" 
                strokeDasharray="3 3"
                segment={[
                  { x: xAxisDomain[0], y: targetResponseTimes.phone },
                  { x: xAxisDomain[1], y: targetResponseTimes.phone }
                ]}
              />
              
              <ReferenceLine 
                y={targetResponseTimes.email} 
                stroke="red" 
                strokeWidth={2}
                isFront={false}
                ifOverflow="extendDomain"
                strokeDasharray="3 3"
                segment={[
                  { x: xAxisDomain[0], y: targetResponseTimes.email },
                  { x: xAxisDomain[1], y: targetResponseTimes.email }
                ]}
              />
              
              <ReferenceLine 
                y={targetResponseTimes.linkedin} 
                stroke="red" 
                strokeWidth={2}
                isFront={false}
                ifOverflow="extendDomain"
                strokeDasharray="3 3"
                segment={[
                  { x: xAxisDomain[0], y: targetResponseTimes.linkedin },
                  { x: xAxisDomain[1], y: targetResponseTimes.linkedin }
                ]}
              />
              
              <ReferenceLine 
                y={targetResponseTimes.other} 
                stroke="red" 
                strokeWidth={2}
                isFront={false}
                ifOverflow="extendDomain"
                strokeDasharray="3 3"
                segment={[
                  { x: xAxisDomain[0], y: targetResponseTimes.other },
                  { x: xAxisDomain[1], y: targetResponseTimes.other }
                ]}
              />
              
              {/* Render each channel as a separate scatter series */}
              <Scatter name="Phone" data={groupedScatterData.phone} fill={COLORS.good}>
                {groupedScatterData.phone.map((entry, index) => (
                  <Cell key={`cell-phone-${index}`} fill={getPointColor(entry)} />
                ))}
              </Scatter>
              
              <Scatter name="Email" data={groupedScatterData.email} fill={COLORS.good}>
                {groupedScatterData.email.map((entry, index) => (
                  <Cell key={`cell-email-${index}`} fill={getPointColor(entry)} />
                ))}
              </Scatter>
              
              <Scatter name="LinkedIn" data={groupedScatterData.linkedin} fill={COLORS.good}>
                {groupedScatterData.linkedin.map((entry, index) => (
                  <Cell key={`cell-linkedin-${index}`} fill={getPointColor(entry)} />
                ))}
              </Scatter>
              
              <Scatter name="Others" data={groupedScatterData.other} fill={COLORS.good}>
                {groupedScatterData.other.map((entry, index) => (
                  <Cell key={`cell-other-${index}`} fill={getPointColor(entry)} />
                ))}
              </Scatter>
            </ScatterChart>
          </ResponsiveContainer>
          </div>
      )}

      <div className="channel-metrics">
        {channelStats.map((channel) => (
          <div 
            key={channel.channel}
            className={`channel-card ${channel.performance}`}
          >
            <div className="channel-icon-container">
              {channelIcons[channel.channel]}
            </div>
            <div className="channel-name">{channel.name}</div>
            <div className="channel-value">{formatResponseTime(channel.avg)}</div>
            <div className="channel-metric">Median: {formatResponseTime(channel.median)}</div>
            <div className="channel-target">Target: {formatResponseTime(channel.target)}</div>
            <div className="channel-count">{channel.count} data points</div>
          </div>
        ))}
      </div>
    </div>
  );
};

export default ResponseChart; 